# ============================================
# Nginx 视频服务配置 - 方案1: 应用层签名临时 URL（URL 解码修复版）
# ============================================
#
# 修复说明：
# 问题：alias 指令不会自动解码 URL 编码的路径，导致中文文件名404
# 解决：使用 root + rewrite 组合，让 Nginx 自动解码 URL
# ============================================

#---------------------------------------------
# 健康检查专用 server
#---------------------------------------------
server {
    listen 80;
    server_name gtm-health;

    location = /gtm-health {
        access_log off;
        return 200 'OK';
        add_header Content-Type text/plain;
    }

    location / {
        return 403;
    }
}

#---------------------------------------------
# 视频服务 server - 应用层签名方案（URL 解码修复）
#---------------------------------------------
server {
    listen 7777 default_server;
    server_name _;

    # ============ 并发连接限制（可选） ============
    # 取消注释以启用：限制单个 IP 最多 5 个并发连接
    # limit_conn perip 5;

    # ============ CORS 配置 ============
    add_header 'Access-Control-Allow-Origin'  '*' always;
    add_header 'Access-Control-Allow-Methods' 'GET, HEAD, OPTIONS' always;
    add_header 'Access-Control-Allow-Headers' 'Range, Origin, Accept, Content-Type, Authorization' always;
    add_header 'Access-Control-Expose-Headers' 'Content-Length, Content-Range, Accept-Ranges' always;

    # ============ 公开访问路径：代理到鉴权服务 ============
    location ~ ^/video/(data[^/]*)/(.*)$ {
        # 提取路径参数
        set $media_type $1;  # data, data1, data2, data_2, data_3_oumeiguochan, ...
        set $file_path $2;   # Movie/xxx.mkv

        # 提取 api_key 参数
        set $api_key '';
        if ($arg_api_key != '') {
            set $api_key $arg_api_key;
        }

        # 代理到鉴权服务
        proxy_pass http://127.0.0.1:8097/api/video-auth/$media_type/$file_path?api_key=$api_key;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 不拦截错误响应，让 302 直接返回给客户端
        proxy_intercept_errors off;

        # 不修改 Location 头，保持相对路径
        proxy_redirect off;

        # 日志
        access_log /var/log/nginx/video_public_access.log combined;
        error_log  /var/log/nginx/video_public_error.log warn;
    }

    # ============ 内部路径：需要 token 验证 ============
    # 使用 root + rewrite 替代 alias，让 Nginx 自动解码 URL
    location ~ ^/internal/(data[^/]*)/(.*)$ {
        # 提取 media_type
        set $media_type $1;

        # 提取 token 参数（从原始请求）
        set $token $arg_token;
        set $expires $arg_expires;
        set $uid $arg_uid;

        # 使用 auth_request 验证 token
        auth_request /auth-verify;
        auth_request_set $auth_status $upstream_status;

        # CORS 头（必须在 location 级别重新声明）
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, HEAD, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Range, Origin, Accept, Content-Type, Authorization' always;
        add_header 'Access-Control-Expose-Headers' 'Content-Length, Content-Range, Accept-Ranges' always;

        # 调试信息
        add_header 'X-Auth-Status' $auth_status always;
        add_header 'X-Media-Type' $media_type always;
        add_header 'Accept-Ranges' bytes always;

        # 根据 media_type 设置 root 路径和 rewrite 规则
        set $root_path '';
        if ($media_type = 'data') {
            set $root_path '/mnt/google';
        }
        if ($media_type = 'data1') {
            set $root_path '/mnt/google1';
        }
        if ($media_type = 'data2') {
            set $root_path '/mnt/google2';
        }
        if ($media_type = 'data3') {
            set $root_path '/mnt/google3';
        }
        if ($media_type = 'data4') {
            set $root_path '/mnt/google4';
        }
        if ($media_type = 'data5') {
            set $root_path '/mnt/google5';
        }
        if ($media_type = 'data6') {
            set $root_path '/mnt/google6';
        }
        if ($media_type = 'data_2') {
            set $root_path '/mnt/google_2';
        }
        if ($media_type = 'data_3_oumeiguochan') {
            set $root_path '/mnt/google_3_oumeiguochan';
        }

        # 重写 URL：移除 /internal/dataX 前缀
        # Nginx 会自动解码 URL 中的百分号编码
        # 注意：必须先匹配更具体的（长路径优先），最后匹配 data
        rewrite ^/internal/data_3_oumeiguochan(.*)$ $1 break;
        rewrite ^/internal/data_2(.*)$ $1 break;
        rewrite ^/internal/data1(.*)$ $1 break;
        rewrite ^/internal/data2(.*)$ $1 break;
        rewrite ^/internal/data3(.*)$ $1 break;
        rewrite ^/internal/data4(.*)$ $1 break;
        rewrite ^/internal/data5(.*)$ $1 break;
        rewrite ^/internal/data6(.*)$ $1 break;
        rewrite ^/internal/data(.*)$ $1 break;

        # 使用 root 指令（会自动解码 URL）
        root $root_path;

        # ========== Range 请求优化 ==========
        # 限制下载速率（避免单个连接占用过多带宽）
        # 前 50 MB 不限速（快速启动播放），之后限制为 50 MB/s
        limit_rate_after 50m;
        limit_rate 50m;

        # 连接超时设置
        send_timeout 300s;  # 5 分钟无数据传输则断开
        keepalive_timeout 300s;

        # ========== 分片大小限制（可选） ==========
        # 使用 slice 模块强制将大文件分片为最大 100MB 的块
        # 注意：启用此选项会增加 Nginx 处理开销，但可以更好地控制缓存和带宽
        # slice 100m;
        # proxy_cache_key $uri$is_args$args$slice_range;
        # proxy_set_header Range $slice_range;
        # proxy_cache_valid 200 206 1h;
        # proxy_buffering on;

        # MIME 类型
        types {
            video/mp4            mp4;
            video/x-matroska     mkv;
            video/webm           webm;
            video/x-msvideo      avi;
            video/quicktime      mov;
            video/x-flv          flv;
            video/MP2T           ts;
            audio/mpeg           mp3;
            audio/x-flac         flac;
            audio/x-wav          wav;
            audio/aac            aac;
            audio/ogg            ogg;
        }

        # 性能优化
        gzip off;
        sendfile on;
        tcp_nopush on;
        tcp_nodelay on;

        # 日志
        access_log /var/log/nginx/video_internal_access.log combined;
        error_log  /var/log/nginx/video_internal_error.log warn;
    }

    # ============ Token 验证接口（内部使用） ============
    location = /auth-verify {
        internal;  # 只能被内部调用

        # 从原始请求 URI 中提取视频路径（去除参数）
        set $video_path $request_uri;
        if ($video_path ~ "^([^?]+)") {
            set $video_path $1;
        }

        # 代理到鉴权服务的 token 验证接口
        # 使用父 location 中定义的 $token, $expires, $uid 变量
        proxy_pass http://127.0.0.1:8097/api/verify-token?token=$token&expires=$expires&uid=$uid&path=$video_path;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # ============ 根路径测试 ============
    location / {
        default_type application/json;
        return 200 '{"status":"ok","message":"Video gateway with signed URL auth (URL decode fixed)","scheme":"application-layer"}';
    }
}
