# Token 自动续期机制

## 问题背景

在 v2.5.0 版本中，我们实现了基于签名临时 URL 的视频鉴权方案：
- ✅ Token 有 5 分钟过期时间（防止分享）
- ❌ **问题**：播放时间超过 5 分钟后，视频会自动 403 中断

这是因为视频播放时，客户端会持续发送 Range 请求下载视频分片，当 Token 过期后，这些请求会被拒绝。

## 解决方案：基于播放会话的自动续期

### 核心设计

我们引入了 **播放会话（Playing Session）** 机制：

1. **首次访问**：用户首次访问视频时，系统创建一个播放会话
2. **自动续期**：每次 Range 请求都会将会话过期时间延长 5 分钟
3. **闲置过期**：如果 5 分钟内没有请求，会话自动过期（防止分享）

### 工作流程

```
用户请求视频
    ↓
生成 5 分钟有效期的 Token（初始 Token）
    ↓
首次验证 Token（auth_request）
    ↓
创建播放会话（Session）
    ↓
后续 Range 请求（auth_request）
    ↓
检测到会话存在 → 自动续期 5 分钟
    ↓
视频可以无限播放（只要不暂停超过 5 分钟）
```

### 技术实现

#### 1. 数据结构

```go
type VideoAuthService struct {
    playingSessions *userkey.Cache  // 播放会话跟踪
    tokenTTL        time.Duration   // 5 分钟
}
```

**会话 Key 格式**：`{token}:{uid}`

**会话 Value**：Unix 时间戳（会话过期时间）

#### 2. 验证逻辑

```go
func (s *VideoAuthService) HandleVerifyToken(c *gin.Context) {
    // 1. 验证 Token 签名（防伪造）

    // 2. 检查是否存在播放会话
    if sessionExpires, ok := s.playingSessions.Get(sessionKey); ok {
        // 会话存在
        if currentTime <= sessionExpires {
            // 会话未过期 → 续期 5 分钟
            s.playingSessions.Set(sessionKey, currentTime + 300)
            return 200  // 验证通过
        } else {
            // 会话已过期（闲置超过 5 分钟）
            return 403  // 拒绝访问
        }
    }

    // 3. 首次访问 → 创建新会话
    s.playingSessions.Set(sessionKey, currentTime + 300)
    return 200
}
```

## 安全性分析

### ✅ 防止 Token 分享

**场景**：用户 A 将 Token URL 分享给用户 B

| 时间线 | 用户 A | 用户 B | 结果 |
|--------|--------|--------|------|
| 0:00 | 获取 Token | - | Session 创建（过期时间 0:05） |
| 0:01 | 正常播放 | 尝试访问 | ✅ 成功（同一 Session） |
| 0:03 | 暂停播放 | - | - |
| 0:09 | 恢复播放 | - | ❌ 403（Session 已过期） |

**关键点**：
- Token 本身仍然有 5 分钟硬过期时间
- 分享的 Token 只能在原始 Session 活跃期间使用
- 闲置 5 分钟后，Session 自动销毁

### ✅ 防止恶意刷新

**场景**：攻击者尝试通过持续发送请求来保持 Token 永久有效

**防御机制**：
1. Session 绑定到 `{token}:{uid}` 组合
2. UID 是基于 `api_key` 的 HMAC 签名（不可伪造）
3. Session 缓存有 30 分钟硬过期（内存回收）
4. 每个 Session 最多延续 30 分钟（缓存 TTL）

### ✅ 防止会话劫持

**场景**：攻击者嗅探到 Token 并尝试劫持会话

**防御机制**：
1. Token 仍然基于 HMAC-SHA256 签名（防篡改）
2. UID 是加密的用户标识（不可逆向）
3. 需要同时拥有 `token`、`expires`、`uid` 三个参数
4. 建议在生产环境使用 HTTPS

## 使用场景

### ✅ 正常播放长视频

```
用户播放 2 小时电影
  ↓
初始 Token: 5 分钟有效期
  ↓
播放 10 分钟 → Session 自动续期
播放 30 分钟 → Session 自动续期
播放 1 小时 → Session 自动续期
...
完整播放 2 小时 ✅
```

### ✅ 暂停后恢复

```
用户播放 30 分钟后暂停
  ↓
4 分钟后恢复 → Session 仍然有效 ✅
  ↓
10 分钟后恢复 → Session 已过期 ❌ (需要重新鉴权)
```

### ❌ 分享 Token

```
用户 A 获取 Token 并分享给用户 B
  ↓
用户 B 在 5 分钟内可以访问（同一 Session）
  ↓
用户 A 停止播放 5 分钟后 → Session 过期
  ↓
用户 B 无法继续访问 ❌
```

## 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `tokenTTL` | 5 分钟 | 初始 Token 有效期 & 会话续期时长 |
| `playingSessions TTL` | 30 分钟 | 会话缓存最大存活时间（硬限制） |
| `uidCache TTL` | 10 分钟 | UID 解密缓存时间 |

## 日志示例

### 首次访问

```
[TokenVerify] 创建播放会话，用户: 1a2b****c3d4, 文件: /internal/data/Movie/xxx.mkv, IP: 192.168.1.100, 会话过期时间: 2025-01-07 14:25:00
```

### 自动续期

```
[TokenVerify] 播放会话续期，用户: 1a2b****c3d4, 文件: /internal/data/Movie/xxx.mkv, IP: 192.168.1.100, 新过期时间: 2025-01-07 14:30:00
```

### 会话过期

```
[TokenVerify] 播放会话已过期（闲置超过5分钟），路径: /internal/data/Movie/xxx.mkv, IP: 192.168.1.100
```

## 性能影响

### 内存占用

每个活跃会话占用：
- Session Key: ~40 字节（token 16 字节 + uid 8 字节 + 分隔符）
- Session Value: ~20 字节（Unix 时间戳字符串）
- 总计：**~60 字节/会话**

假设 1000 个并发播放用户：
- 内存占用：60 KB（可忽略）

### CPU 开销

- 每次 Range 请求：1 次 Map 查找 + 1 次 Map 写入
- 时间复杂度：O(1)
- 额外延迟：< 0.1ms（可忽略）

## 兼容性

### ✅ 完全兼容

- 不改变 Token 生成逻辑
- 不改变 Nginx 配置
- 不需要修改客户端
- 向后兼容旧版本

### ⚠️ 注意事项

1. **重启清空会话**：服务重启后，所有播放会话会丢失（用户需要重新鉴权）
2. **多实例问题**：如果部署多个实例，会话不共享（建议使用 Redis 存储会话）
3. **长时间播放**：会话最长存活时间受 `playingSessions TTL` 限制（默认 30 分钟）

## 未来优化

1. **Redis 存储会话**：支持多实例部署和重启后恢复
2. **可配置续期时间**：允许通过配置文件调整续期策略
3. **分级续期**：短视频 5 分钟，长视频 10 分钟
4. **会话统计**：记录播放时长、暂停次数等数据

## 测试验证

### 测试场景 1：播放超过 5 分钟

1. 在 Emby 中开始播放视频
2. 持续播放 10 分钟
3. **预期结果**：视频正常播放，不会 403 ✅

### 测试场景 2：暂停后恢复

1. 播放 2 分钟后暂停
2. 等待 3 分钟后恢复
3. **预期结果**：正常恢复播放 ✅
4. 等待 6 分钟后恢复
5. **预期结果**：需要重新加载视频（302 重定向）❌

### 测试场景 3：分享 Token

1. 用户 A 获取视频 URL（包含 Token）
2. 分享给用户 B
3. 用户 B 在 5 分钟内访问：**成功** ⚠️
4. 用户 A 停止播放 5 分钟后
5. 用户 B 尝试访问：**失败** ✅

## 总结

通过引入播放会话机制，我们成功解决了 Token 过期导致的视频中断问题，同时保持了防分享的安全性：

| 特性 | v2.5.0 之前 | v2.5.1 之后 |
|------|-------------|-------------|
| 播放时长限制 | ❌ 5 分钟 | ✅ 无限制 |
| 防止分享 | ✅ 5 分钟过期 | ✅ 闲置 5 分钟过期 |
| 暂停恢复 | ❌ 可能失败 | ✅ 5 分钟内恢复 |
| 性能开销 | 低 | 极低 |
| 安全性 | 高 | 高 |
